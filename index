video_progress = {}

# Hàm kiểm tra và lấy đường dẫn ffmpeg
def get_ffmpeg_bin(ffmpeg_path):
    if ffmpeg_path and os.path.exists(os.path.join(ffmpeg_path, "ffmpeg.exe")):
        return ffmpeg_path
    default_path = os.path.join(os.getcwd(), "ffmpeg/bin")
    if os.path.exists(os.path.join(default_path, "ffmpeg.exe")):
        return default_path
    else:
        messagebox.showerror("Error", "Không tìm thấy FFmpeg. Vui lòng kiểm tra lại.")
        return None

# Hàm mã hóa tên video ngắn gọn
def hash_video_name(input_str):
    ascii_str = input_str.encode('ascii', 'ignore').decode('ascii')
    
    # Loại bỏ các ký tự không phải chữ và số
    cleaned_str = ''.join(char for char in ascii_str if char.isalnum())
    
    return cleaned_str

# Hàm tách khung hình và âm thanh
def process_video(video_path, interval, ffmpeg_bin):
    try:
        video_name = os.path.splitext(os.path.basename(video_path))[0]
        video_key = hash_video_name(video_name)
        frame_output_dir = f"frames/{video_name}"
        audio_output = f"{frame_output_dir}/audio.wav"
        result_video = f"result/{video_name}.mp4"
        
        os.makedirs(frame_output_dir, exist_ok=True)
        os.makedirs("result", exist_ok=True)

        # Tách khung hình
        output_path = os.path.join(frame_output_dir, 'frame_%04d.png')
        ffmpeg.input(video_path).output(output_path, vf=f'fps=1/{interval}').run(cmd=os.path.join(ffmpeg_bin, 'ffmpeg'))

        # Tách âm thanh
        ffmpeg.input(video_path).output(audio_output, vn=None).run(cmd=os.path.join(ffmpeg_bin, 'ffmpeg'))

        # Tạo video mới từ các khung hình và âm thanh
        create_video_with_transitions(frame_output_dir, interval, audio_output, result_video, ffmpeg_bin, video_key)

    except Exception as e:
        messagebox.showerror("Error", f"Lỗi khi xử lý video: {e}")

# Hàm tạo video mới từ các khung hình và giữ âm thanh gốc với hiệu ứng chuyển cảnh
def create_video_with_transitions(frame_dir, interval, audio_path, output_video, ffmpeg_bin, video_key):
    try:
        transitions = [
            "fade", "wipeleft", "wiperight", "wipeup", "wipedown",
            "slideleft", "slideright", "slideup", "slidedown", "circlecrop"
        ]

        images = sorted([os.path.join(frame_dir, f) for f in os.listdir(frame_dir) if f.endswith(".png")])

        if len(images) < 2:
            raise Exception("Cần ít nhất 2 ảnh để tạo video.")

        temp_videos = []
        
        # Tạo video tạm thời cho từng cặp ảnh và hiệu ứng chuyển cảnh giữa chúng
        for i in range(len(images) - 1):
            temp_video = os.path.join(frame_dir, f"temp_{i}.mp4")
            effect = random.choice(transitions)

            # Lệnh để tạo video tạm thời cho từng cặp ảnh với hiệu ứng chuyển cảnh
            command = [
                os.path.join(ffmpeg_bin, 'ffmpeg'),
                '-y',
                '-loop', '1', '-t', str(interval), '-i', images[i],
                '-loop', '1', '-t', str(interval), '-i', images[i + 1],
                '-filter_complex', f"[0:v][1:v]xfade=transition={effect}:duration=1.0:offset=0[v]",
                '-map', '[v]',
                '-c:v', 'libx264', '-pix_fmt', 'yuv420p',
                temp_video
            ]

            ff = FfmpegProgress(command)
            for progress in ff.run_command_with_progress():
                update_individual_progress(video_key, progress / len(images))

            temp_videos.append(temp_video)

        # Kiểm tra file tạm thời và tạo concat_list.txt
        concat_list_file = os.path.join(frame_dir, "concat_list.txt")
        with open(concat_list_file, "w") as f:
            for temp_video in temp_videos:
                f.write(f"file '{os.path.abspath(temp_video)}'\n")

        # Lệnh FFmpeg để ghép nối video cuối cùng
        final_command = [
            os.path.join(ffmpeg_bin, 'ffmpeg'),
            '-y',
            '-f', 'concat', '-safe', '0', '-i', concat_list_file,
            '-i', audio_path,
            '-c:v', 'libx264', '-c:a', 'aac', '-b:a', '192k',
            output_video
        ]

        ff = FfmpegProgress(final_command)
        for progress in ff.run_command_with_progress():
            update_individual_progress(video_key, progress / 100)
    except Exception as e:
        tb = e.__traceback__
        error_message = f"Exception: {e} | "
        while tb is not None:
            filename = tb.tb_frame.f_code.co_filename
            lineno = tb.tb_lineno
            function_name = tb.tb_frame.f_code.co_name
            error_message += f"File: {filename}, Line: {lineno}, in {function_name}\n"
            tb = tb.tb_next
        open("log.txt", "a").write(f"{error_message}\n")
        messagebox.showerror("Error", f"Lỗi khi tạo video với hiệu ứng: {e}")

# Cập nhật tiến trình của từng video và tính tiến trình tổng
def update_individual_progress(video_key, progress):
    video_progress[video_key] = progress
    total_progress = sum(video_progress.values()) / len(video_progress)
    progress_bar.set(total_progress)
    progress_label.configure(text=f"Tiến trình tổng: {int(total_progress * 100)}%")

# Giao diện xử lý
def process_videos_in_threads():
    def run():
        video_dir = file_path_entry.get()
        print(ffmpeg_path_entry.get())
        ffmpeg_bin = get_ffmpeg_bin(ffmpeg_path_entry.get())
        interval = float(interval_entry.get())

        if not os.path.exists(video_dir):
            messagebox.showerror("Error", "Thư mục video không tồn tại!")
            return
        video_files = [os.path.join(video_dir, f) for f in os.listdir(video_dir) if f.endswith(".mp4")]

        def process_task(lock):
            with lock:
                video = video_files.pop(0)
                video_name = os.path.splitext(os.path.basename(video))[0]
                video_key = hash_video_name(video_name)
                video_progress[video_key] = 0 
            process_video(video, interval, ffmpeg_bin)

        threads = []
        so_luong = int(luong.get())
        for i in range(so_luong):
                t = threading.Thread(target=process_task, args=(threading.Lock(),))
                threads.append(t)

        for t in threads:
            t.start()
        for t in threads:
            t.join()

        messagebox.showinfo("Success", "Đã hoàn thành xử lý tất cả video.")
    threading.Thread(target=run).start()


# Giao diện CustomTkinter
app = ctk.CTk()
app.title("Quản lý Video FFmpeg đa luồng")
app.geometry("500x650")

ctk.CTkLabel(app, text="Thư mục chứa video MP4").pack(pady=5)
file_path_entry = ctk.CTkEntry(app, placeholder_text="Nhập đường dẫn đến thư mục video", width=400)
file_path_entry.pack(pady=5)
ctk.CTkButton(app, text="Chọn Thư Mục", command=lambda: file_path_entry.insert(0, filedialog.askdirectory())).pack(pady=5)

ctk.CTkLabel(app, text="Đường dẫn FFmpeg (để trống nếu mặc định)").pack(pady=5)
ffmpeg_path_entry = ctk.CTkEntry(app, placeholder_text="Nhập đường dẫn thư mục ffmpeg/bin", width=400)
ffmpeg_path_entry.pack(pady=5)
ctk.CTkButton(app, text="Chọn Đường Dẫn", command=lambda: ffmpeg_path_entry.insert(0, filedialog.askdirectory())).pack(pady=5)

ctk.CTkLabel(app, text="Khoảng thời gian giữa các ảnh (giây)").pack(pady=5)
interval_entry = ctk.CTkEntry(app, placeholder_text="Nhập số giây", width=200)
interval_entry.pack(pady=5)


ctk.CTkLabel(app, text="Số luồng").pack(pady=5)
luong = ctk.CTkEntry(app, placeholder_text="Nhập số luong", width=200)
luong.pack(pady=5)

ctk.CTkButton(app, text="Chạy", command=process_videos_in_threads).pack(pady=20)

ctk.CTkLabel(app, text="Tiến trình tổng").pack(pady=10)
progress_bar = ctk.CTkProgressBar(app, width=400)
progress_bar.pack(pady=5)
progress_bar.set(0)
progress_label = ctk.CTkLabel(app, text="0%")
progress_label.pack()

app.mainloop()
